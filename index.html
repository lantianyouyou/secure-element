<!DOCTYPE html>
<html>
  <head>
    <title>
      Secure Element API
    </title>
    <meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' async=""
    class='remove'>
</script><!--
    <script src='../../editing/respec-w3c-common.js' async="" class='remove'></script>
    -->

    <script class='remove'>
/*Respec configuration*/
    var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "secure-element",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://opoto.github.io/secure-element",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              {
                  name:       "Olivier Potonni√©e"
              ,   company:    "Gemalto"
              ,   companyURL: "http://www.gemalto.com/"
              },
              {
                  name:       "Dzung D Tran"
              ,   company:    "Intel"
              ,   companyURL: "http://www.intel.com/"
              },
          ],
          
          // name of the WG
          wg:           "System Applications Working Group",
          
          // URI of the public WG page
          wgURI:        "http://www.w3.org/2012/sysapps/",
          
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-sysapps",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/58119/status",
          // !!!! IMPORTANT !!!! MAKE THE ABOVE BLINK IN YOUR HEAD

          localBiblio:  {
            "dummy" : "dummy"
            , "ETSI-102216": {
                    title:    "TR 102 216 : Smart cards; Vocabulary for Smart Card Platform specifications"
                ,   href:     "http://webapp.etsi.org/workprogram/Report_WorkItem.asp?WKI_ID=18815&curItemNr=1&totalNrItems=1&optDisplay=10&qSORT=HIGHVERSION&qETSI_STANDARD_TYPE=%27TR%27&qETSI_NUMBER=102+216"
                ,   authors:  [ "ETSI" ]
                ,   publisher:  "ETSI"
              }
            , "ISO7816-3": {
                    title:    "7816-3 Identification cards -- Integrated circuit cards -- Part 3: Cards with contacts -- Electrical interface and transmission protocols"
                ,   href:     "http://www.iso.org/iso/fr/home/store/catalogue_tc/catalogue_detail.htm?csnumber=38770"
                ,   authors:  [ "ISO/IEC" ]
                ,   publisher:  "ISO"
              }
            , "ISO7816-4": {
                    title:    "7816-4 Identification cards -- Integrated circuit cards -- Part 4: Organization, security and commands for interchange"
                ,   href:     "http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=54550"
                ,   authors:  [ "ISO/IEC" ]
                ,   publisher:  "ISO"
              }
            , "ISO7816-5": {
                    title:    "7816-5 Identification cards -- Integrated circuit cards -- Part 5: Registration of application providers"
                ,   href:     "http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=34259"
                ,   authors:  [ "ISO/IEC" ]
                ,   publisher:  "ISO"
              }
            , "WEBCRYPTO": {
                    title:    "Web Cryptography API"
                ,   href:     "http://www.w3.org/TR/WebCryptoAPI/"
                ,   authors:  [ "W3C Web Cryptography Working Group" ]
                ,   publisher:  "W3C"
              }
            , "NFC": {
                    title:    "Web NFC API"
                ,   href:     "http://htmlpreview.github.io/?https://github.com/w3c/nfc/blob/master/proposals/common/nfc.html"
                ,   authors:  [ "W3C Near Field Communications (NFC) Working Group" ]
                ,   publisher:  "W3C"
              }
            , "SYSAPPS": {
                    title:    "Runtime and Security Model for Web Applications"
                ,   href:     "http://www.w3.org/TR/runtime/"
                ,   authors:  [ "W3C SysApps Working Group" ]
                ,   publisher:  "W3C"
              }
            , "GP": {
                    title:    "Card specifications"
                ,   authors:  [ "GlobalPlatform" ]
                ,   href:     "http://www.globalplatform.org/specificationscard.asp"
                ,   publisher:  "GlobalPlatform"
              }
          }
      };
    </script>
  </head>
  <body>
    <!-- - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - -->
    <section id="abstract">
      <p>
        A secure element is a tamper proof device, providing a secure storage
        and execution environment for sensitive data and processing. It offers
        both physical and logical protection against attacks, ensuring
        integrity and confidentiality of its content.
      </p>
      <p>
        This specification defines a communication interface between a web
        application and a secure element. It makes no assumption on the secure
        element type, application domain, or physical communication media.
      </p>
    </section>
    <!-- - - - - - - - - - -  Status of this document - - - - - - - - - - - -->
    <section id="sotd">
      <p>
        <strong>This work-in-progress specification is an unofficial draft.
        Developers are strongly discouraged to implement it at this
        stage.</strong> If you are interested in implementing or using this
        API, we encourage you to contact the editors or post on the working
        group <a href=
        "http://lists.w3.org/Archives/Public/public-sysapps/">mailing list</a>.
      </p>
      <p>
        See <a href="#Changes">Changes section</a> for history details.
      </p>
    </section>
    <!-- - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - -->
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        The <cite>Secure Element API</cite> defined herein allows applications
        to interact with secure elements. Considered secure elements are those
        complying to [[!ISO7816-4]], which defines a command/response protocol,
        based on structured <abbr title="Application Data Unit">APDU</abbr>
        (Application Data Unit).
      </p>
      <!-- - - - - - - - - - - -  Technical Background  - - - - - - - - - - - -->
      <section>
        <h2>
          Technical Background
        </h2>
        <p>
          Secure elements addressed by this specification are micro controllers
          that may come in different form factors, such as:
        </p>
        <ul>
          <li>Smart cards. The chip is embedded in a plastic card usually of
          the size of a typical credit card. The card may show physical
          contacts to communicate with the chip, or the chip may support
          <abbr title="Near Field Communication">NFC</abbr> (Near Field
          Communication), in which case the plastic card embeds an antenna.
          Some cards also support both communication methods.
          </li>
          <li>
            <a><abbr title="Universal Integrated Circuit Card">UICC</abbr></a>
            cards are smart cards used in cellular telephony, which may be
            delivered in different sizes. They are often called <abbr title=
            "Subscriber Identity Module">SIM</abbr>, which is actually the name
            of the application hosted by the <a>UICC</a> to access GSM
            networks. <a>UICC</a> may however host other applications.
          </li>
          <li>Smart <abbr title="Storage Device">SD</abbr> cards have a similar
          form as usual SD cards, but internally include a secure element, and
          support an extended set of SD commands to communicate with the secure
          element. Some of these smart SD cards also support NFC.
          </li>
          <li>Embedded secure elements, which are chips directly bonded on the
          device mother board. Unlike other form factors, this one does not
          allow interchanging or extracting the secure element, it is
          permanently attached to the device.
          </li>
        </ul>
        <p>
          Similarly to a computer, a secure element may host one or multiple
          applications. Typical applications are mobile network authentication
          (SIM cards), payment (credit cards), authentication and signature
          (corporate badges, eID, etc.), loyalty, ticketing (public
          transports). But these are only examples, many other applications
          have been and can be deployed.
        </p>
        <p>
          Applications hosted by the secure elements are commonly named
          <dfn>on-card</dfn> applications. Considering the limited, if any,
          user interface of these devices, and application can only be useful
          for a user if there is also an off-card application part, which
          handle the dialog with the user, or with external computing
          resources. Examples of <dfn>off-card</dfn> applications are
          <abbr title="Automatic Toll Machines">ATM</abbr> for payment, mail
          applications for signature, access control doors for authentication,
          etc. This specification defines the API to be used by off-card
          applications based on web technologies.
        </p>
      </section><!-- Technical Background -->
      <!-- - - - - - - - - - - - Use Cases - - - - - - - - - - - -->
      <section>
        <h2>
          Use Cases
        </h2>
        <p>
          This specification allows development of web applications making use
          of these secure element applications. Some typical use cases that
          applications can address based on this API include:
        </p>
        <ul>
          <li>
            <strong>Authentication:</strong> Instead of user name and password,
            access to an online service may be protected by a strong
            authentication mechanism, based on credentials stored and processed
            in a secure element. In web-based operating systems, system
            applications such as <abbr title=
            "Virtual Private Network">VPN</abbr> (Virtual Private Network) or
            eMail application may use of the secure element to authenticate the
            user.
          </li>
          <li>
            <strong>Digital Signature:</strong> Applications may use the secure
            element to digitally sign a document or any data with a key stored
            in this secure element. The signature operation itself is executed
            inside the secure element, ensuring both the integrity of the
            signature and the confidentiality of the key used in this process.
            For instance, this could be used by an eMail application to sign
            emails sent by the user. Or by a government web application to sign
            a online administrative request.
          </li>
          <li>
            <strong>Payment:</strong> Online commerce may use widely used smart
            credit cards, or specific payment applications, to enforce the
            security of online transactions. On cellular telephony environment,
            the on-card payment application may be hosted on the SIM card,
            alleviating the need for the user to handle multiple physical
            devices.
          </li>
          <li>
            <strong>Credential provisioning:</strong> The content of a secure
            element may be updated to install, update or remove an application
            or any credential it may host. For instance a public transport
            application may offer a user to credit her NFC-enabled transport
            card with tickets bought online. Or a corporate intranet web
            application may offer employees to renew online the X.509
            certificates hosted in their corporate badge, so that they can do
            this operation from anywhere just before these certificates expire.
          </li>
        </ul>
        <p>
          Whatever the form factor listed above, secure element considered in
          this specification implement the same [[!ISO7816-4]] transport
          protocol. The physical media (USB, NFC, or any other wired or
          wireless technique) used in this communication is abstracted by the
          API defined in this specification.
        </p>
      </section><!-- Use Cases -->
      <!-- - - - - - - - - - - - - -  Relationship to other W3C APIs - - - - - - - - - - - - - -->
      <section>
        <h2>
          Relationship to other W3C APIs
        </h2>
        <p>
          This specification, although addressing some concepts similar to
          other W3C specifications, has distinct use cases and offer different
          level of services:
        </p>
        <ul>
          <li>The current NFC API draft specification [[NFC]] defines an API
          allowing to exchange NDEF messages with NFC tags or peers. While the
          Secure Element API specified herein allows web applications to send
          commands to secure elements wired or plugged in the device, or
          wirelessly connected to the device thanks to NFC technology. The
          difference between the different communication links (wired or NFC)
          is only visible through secure element type in this API, but does not
          impact the way applications would interact with the secure element.
          As such there is no overlap of functionalities between the two APIs.
          </li>
          <li>The Web Cryptography API draft specification [[WEBCRYPTO]]
          defines an API allowing a web application to invoke cryptographic
          services. Its implementation is independent from the underlying
          layers performing the actual cryptographic operations: it might be
          pure software, or use a dedicated hardware such as a secure element
          or a TPM. As such there is not overlap between the two APIs.
          Nevertheless one can imagine that the User Agent implementing the Web
          Cryptography API may rely on the Secure Element API, but this will be
          implementation dependent.
          </li>
        </ul>
      </section><!-- Relationship to other W3C APIs -->
    </section><!-- Introduction -->
    <!-- - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - -->
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in
        this specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]],
        as this specification uses that specification and terminology.
      </p>
    </section><!-- Conformance -->
    <!-- - - - - - - - - - - - - -  Dependencies  - - - - - - - - - - - - - -->
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        This specification depends on the following interfaces and concepts
        defined in other specifications.
      </p>
      <p>
        The following dependencies are defined in [[!HTML]]: <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#event-handlers">event
        handler</a></dfn>, <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#origin">origin</a></dfn>.
      </p>
      <p>
        The following dependencies are defined in [[!DOM4]]: the <dfn><a href=
        "http://dom.spec.whatwg.org/#event"><code>Event</code></a></dfn> and
        the <dfn><a href=
        "http://dom.spec.whatwg.org/#promise"><code>Promise</code></a></dfn>
        interfaces, the concepts of a <a href=
        "http://dom.spec.whatwg.org/#concept-resolver"><dfn>resolver</dfn></a>,
        <dfn><a href="http://dom.spec.whatwg.org/#concept-event-fire">fire an
        event</a></dfn>.
      </p>
      <p>
        Some secure element concepts are defined in ISO/IEC specifications:
      </p>
      <ul>
        <li>
          <dfn><abbr title="Answer to Reset">ATR</abbr></dfn> (Answer to Reset)
          is defined in [[!ISO7816-3]]
        </li>
        <li>
          <dfn>APDU command</dfn>, <dfn>APDU response</dfn>, <dfn>class
          byte</dfn>, <dfn>instruction byte</dfn>, <dfn>parameter bytes</dfn>,
          <dfn>data field bytes</dfn>, <dfn>status word</dfn>, <dfn>basic
          channel</dfn> and <dfn>logical channel</dfn> are defined in
          [[!ISO7816-4]]
        </li>
        <li>
          <dfn><abbr title="Application Identifier">AID</abbr></dfn>
          (Application Identifier) is defined in [[!ISO7816-5]].
        </li>
        <li>
          <dfn>UICC</dfn> is defined in [[!ETSI-102216]]
        </li>
      </ul>
    </section><!-- Dependencies -->
    <!-- - - - - - - - - - - - - - Security  - - - - - - - - - - - - - - - - -->
    <section class="informative">
      <h2>
        Security and privacy considerations
      </h2>
      <p>
        Using a secure element may bring additional security to a web
        application, but is not sufficient to ensure the application is secure.
        In particular, developers using the Secure Element API should be aware
        of the following security considerations:
      </p>
      <ul>
        <li>
          <strong>Communication</strong> between the secure element and the web
          application has to be secured, in order to ensure the confidentiality
          and integrity of the message exchange. This can either be achieved if
          the web application using the secure element API executes in a
          trusted execution environment offering guarantees on the integrity
          and confidentiality of the communication link. Or it can be provided
          programmatically by encryption and/or MACing of the messages
          exchanged with the secure element (e.g. using GlobalPlatform's secure
          messaging technology [[GP]]). The off-card processing of these
          messages has then to be done in a trusted execution environment,
          which may be on the device to which the secure element is connected,
          or on a remote device (e.g. the web application's originating
          server).
        </li>
        <li>
          <strong>Interface</strong> between the user and the web application
          typically consists in displayed text and images (e.g. a transaction
          confirmation dialog), and user inputs (e.g. a PIN code). Protecting
          this interface is out of the scope of this specification. If the
          application requires such guarantee, it should restrict its execution
          on Trusted Execution Environments.
        </li>
        <li>
          <strong>Access</strong> to secure element applications should be
          restricted to authorized parties. The secure element embedded
          application may enforce such control by requiring authentication of
          the off-card communicating party. Some implementation of this control
          may require the cooperation of the web application runtime: for
          instance the GlobalPlatform access control mechanism [[GP]] requires
          the runtime to send the off-card application signature to the secure
          element for the latter to verify if it is authorized or not. These
          controls are out of scope of the herein specification.
        </li>
        <li>
          <strong>Traceability</strong> of the user may be facilitated by the
          unique identifying information the secure element may contain. In
          addition to the access control implemented by the card, the web
          application runtime should make sure that only trusted applications
          (signed by a trusted party, as defined by the [[SYSAPPS]]) have
          access to the secure element API, and user has to explicitly allow
          this application to execute.
        </li>
      </ul>
    </section><!-- Security -->
    <!-- - - - - - - - - - - - - -  Secure Element Services  - - - - - - - - - - -->
    <section class="informative">
      <h2>
        Secure Element services
      </h2>
      <p>
        Communication with a secure element is performed through a
        <dfn>reader</dfn>, which unlike its name suggests it not only able to
        read content from secure element, but also to write or send any
        application specific command. Given the removal nature of many secure
        elements, a reader may be empty, meaning that no secure element is
        connected to this reader. For instance, a USB smart card reader may be
        connected to a computer, but no smart card is inserted. Or a device may
        support NFC interactions with secure elements, but none is in the
        field. For this reason, the API provides a mean to query the list of
        available readers, and for each of them if they are empty or if a
        secure element is present. In addition, this specification defines
        events that are triggered when a secure element is connected to a
        reader, and also when it is disconnected.
      </p>
      <p>
        Once a web application is informed that a reader has a connected secure
        element, it can open a <dfn>session</dfn> with it. Opening a session
        establishes the communication between the web application and the
        secure element, and provides a session object to the application.
        However a secure element is just an application container, and the web
        application still needs to identify the application with which it wants
        to communicate.
      </p>
      <p>
        To this intent, the session object provides a mean to open a
        <dfn>channel</dfn> with a specific secure element application, which is
        uniquely identified by an <a>AID</a>. The web application runtime and
        the secure element may then perform some internal security checking to
        ensure the web application is allowed to connect to this secure element
        application. If authorized, the returned channel object is the one
        providing the method to send commands to the secure element
        application, and get the corresponding responses.
      </p>
      <p>
        The above steps required to send a command to a secure element creates
        a set of chained objects. A reader may have several opened sessions,
        which may have several opened channels. Each object has a
        <code>close()</code> method to release all ressources associated to the
        target object, and invoke <code>close()</code> method on all underlying
        objects in the chain.
      </p>
      <figure>
        <a href="#class-graph"><img src="images/class-graph.png" alt=
        "Class graph"></a>
        <figcaption id="class-graph">
          The figure above represents the class relationships between the
          secure element entities introduced in this specification.
        </figcaption>
      </figure>
    </section><!-- Secure Element Services -->
    <!-- - - - - - - - - - - - Interface Navigator - - - - - - - - - -->
    <section>
      <h2>
        <a>Navigator</a> Interface
      </h2>
      <p>
        The <a>Navigator</a> exposes the secure element service.
      </p>
      <dl title="partial interface Navigator" class="idl">
        <dt>
          readonly attribute SecureElementManager secureElementManager
        </dt>
        <dd>
          When getting the <dfn id=
          "widl-Navigator-secureElement">secureElementManager</dfn> attribute,
          the user agent MUST return the <a>SecureElementManager</a> object
          that provides access to available secure element readers. If the user
          agent doesn't support secure element features, it MUST then return
          <code>null</code>.
        </dd>
      </dl>
    </section><!-- Interface Navigator -->
    <!-- - - - - - - - - - - - Interface SecureElement - - - - - - - - - -->
    <section>
      <h2>
        <a>SecureElementManager</a> Interface
      </h2>
      <p>
        The <a>SecureElementManager</a> interface provides access to secure
        element readers, and is the source of events notifying the presence of
        secure elements.
      </p>
      <dl title="interface SecureElementManager : EventTarget" class="idl">
        <dt>
          readonly attribute Reader[] readers
        </dt>
        <dd>
          This attribute MUST return the list of available readers in which a
          secure element may be present. Its value MUST be an empty array if no
          reader is available. It MUST be <code>null</code> if the
          <code>close()</code> method has been closed on this
          <a>SecureElementManager</a> object. Several requests of this
          attribute MAY return a different array value, because new readers may
          become available, while others may be disconnected.
        </dd>
        <dt>
          attribute EventHandler onsepresent
        </dt>
        <dd>
          Event handler for the SE-present event. This event MUST be triggered
          each time any of the following situations occurs:
          <ul>
            <li>Application starts while a secure element is present in a
            reader
            </li>
            <li>Application is running, a reader which was already listed in
            the readers attribute but had no secure element now detects a
            present secure element.
            </li>
            <li>Application is running, a new reader is detected and has a
            secure element present.
            </li>
          </ul>
        </dd>
        <dt>
          attribute EventHandler onseremoval
        </dt>
        <dd>
          Event handler for the SE-removal event. This event MUST be triggered
          when a secure element which was present in a reader is not present
          anymore (it has been unplugged, or is out of reach if it was
          connected through wireless communication). As soon as this event is
          triggered, all <a>Reader</a>, <a>Session</a> and <a>Channel</a>
          objects providing access to this secure element are marked as closed.
          Calling <code>openSession()</code> on the reader,
          <code>openBasicChannel()</code> or <code>openLogicalChannel()</code>
          on an associated session, or <code>transmit()</code> on a previously
          opened channel MUST fail, with the "closed" SEError value.
        </dd>
        <dt>
          Promise&amp;lt;SecureElementManager> close()
        </dt>
        <dd>
          <div class="note" id="note-promise">
            This API makes extensive use of the <a>Promise</a> type for
            asynchronous operations. Considering the instability of this type's
            definition, we only give API description for
            <code>SecureElementManager</code>'s <code>close()</code> method.
            This will be complemented when <a>Promise</a> is stable.
          </div>
          <p>
            This method closes all readers and descendent <a>Session</a> and
            <a>Channel</a> objects. When invoked, the user agent MUST run the
            following steps:
          </p>
          <ol>
            <li>Let <var>promise</var> be a new <a>Promise</a> object and <var>
              resolver</var> its associated <code>resolver</code>.
            </li>
            <li>Return <var>promise</var> to the caller and continue the
            following steps asynchronously.
            </li>
            <li>If the <code>close()</code> method has already been called on
            this object, then invoke <var>resolver</var>'s
            <code>accept()</code> method with this <a>SecureElementManager</a>
            object, and exit those steps.
            </li>
            <li>Let <var>countdown</var> be the number of readers in the <code>
              readers</code> attribute, and <var>errors</var> an integer
              initialized to 0.
            </li>
            <li>Invoke <code>close()</code> method on each <a>Reader</a> object
            in the array returned by the <code>readers</code> attribute.
            </li>
            <li>Let <var>readerpromises</var> be the set of <a>Promise</a>
            objects returned by these <code>close()</code> invocations.
            </li>
            <li>Set the <code>readers</code> attribute value to
            <code>null</code>.
            </li>
            <li>If <var>countdown</var> is 0, then invoke <var>resolver</var>'s
            <code>accept()</code> method with this <a>SecureElementManager</a>
            object, and exit those steps.
            </li>
            <li>When the <code>accept()</code> method of an element of
            <var>readerpromises</var> set is invoked, <var>countdown</var> is
            decremented. If <var>countdown</var> is 0 and <var>errors</var> is
            0, then invoke <var>resolver</var>'s <code>accept()</code> method
            with this <a>SecureElementManager</a> object. If
            <var>countdown</var> is 0 and <var>errors</var> is greater than 0,
            then invoke <var>resolver</var>'s <code>reject()</code> method with
            an <a>SEError</a> object.
            </li>
            <li>When the <code>reject()</code> method of an element of
            <var>readerpromises</var> set is invoked, <var>countdown</var> is
            decremented, and <var>errors</var> is incremented. If
            <var>countdown</var> is 0 then invoke <var>resolver</var>'s <code>
              reject()</code> method with an <a>SEError</a> object.
            </li>
          </ol>
        </dd>
      </dl>
    </section><!-- Interface SecureElementManager -->
    <!-- - - - - - - - - - - - Interface Reader - - - - - - - - - -->
    <section>
      <h2>
        <a>Reader</a> Interface
      </h2>
      <p>
        Readers connected to this device are accessible though the
        <a>Reader</a> interface. A reader is the connector to a secure element.
        Given the removable nature of some secure elements, a reader may or may
        not have a secure element present. A reader may have at most one
        present secure element simultaneously. A reader MAY for instance be a
        <a>UICC</a> slot, a USB smart card reader, an NFC interface, or a
        mother board slot where a embedded secure element is wired.
      </p>
      <dl title="interface Reader" class="idl">
        <dt>
          readonly attribute boolean isSEPresent
        </dt>
        <dd>
          This attribute MUST return true if a secure element is present in
          this reader. It MUST return false otherwise.
        </dd>
        <dt>
          readonly attribute DOMString name
        </dt>
        <dd>
          This attribute MUST return the name of the reader. This is an
          arbitrary name set by the system. It MAY be computed based on ready
          provided data.
        </dd>
        <dt>
          readonly attribute SecureElementType secureElementType
        </dt>
        <dd>
          This attribute MUST return the <a>SecureElementType</a> value best
          matching the type of the secure element this reader gives access to.
          This information may be useful for applications that target a
          specific secure element type. It may also be used to build the
          application user interface, to represent the secure element in a
          realistic way.
        </dd>
        <dt>
          readonly attribute ConnectivityType connectivityType
        </dt>
        <dd>
          This attribute MUST return the <a>ConnectivityType</a> value matching
          the connectivity used by the reader to communicate with the secure
          element.
        </dd>
        <dt>
          Promise&amp;lt;Session> openSession()
        </dt>
        <dd>
          This method establishes a communication link with a secure element.
          There may be several sessions opened at the same time, hence a
          session MUST NOT lock access to the secure element.
          <div class="note">
            See <a href="#note-promise">note on <code>Promise</code></a>
          </div>
        </dd>
        <dt>
          Promise&amp;lt;Reader> close()
        </dt>
        <dd>
          This method closes all sessions opened by this reader, and their
          descendent <a>Channel</a> objects. Invoking <code>close()</code>
          method on an already closed reader is an idempotent operation.
          <div class="note">
            See <a href="#note-promise">note on <code>Promise</code></a>
          </div>
        </dd>
      </dl>
      <!-- - - - - - - - - - - - Enum SecureElementType - - - - - - - - - -->
      <section>
        <h2>
          <a>SecureElementType</a> enum
        </h2>
        <p>
          The <a>SecureElementType</a> enum identifies the type of the secure
          element a reader gives access to.
        </p>
        <dl title="enum SecureElementType" class="idl">
          <dt>
            uicc
          </dt>
          <dd>
            The secure element is a <a>UICC</a> used by the device to connect
            to a mobile network.
          </dd>
          <dt>
            smartcard
          </dt>
          <dd>
            The secure element is a smart card.
          </dd>
          <dt>
            chip
          </dt>
          <dd>
            The secure element is a dedicated chip in the device.
          </dd>
          <dt>
            sd
          </dt>
          <dd>
            The secure element is a SD card, and may be unplugged.
          </dd>
          <dt>
            other
          </dt>
          <dd>
            For any other secure element type not listed above.
          </dd>
        </dl>
      </section><!-- Enum SecureElementType -->
      <!-- - - - - - - - - - - - Enum ConnectivityType - - - - - - - - - -->
      <section>
        <h2>
          <a>ConnectivityType</a> enum
        </h2>
        <p>
          The <a>ConnectivityType</a> enum identifies the type of the secure
          element a reader gives access to.
        </p>
        <dl title="enum ConnectivityType" class="idl">
          <dt>
            embedded
          </dt>
          <dd>
            The secure element is physically attached to the device, and cannot
            be removed, at least without powering off the device.
          </dd>
          <dt>
            plugged
          </dt>
          <dd>
            The secure element is plugged to the device, and can be unplugged.
          </dd>
          <dt>
            wireless
          </dt>
          <dd>
            The secure element is accessed though wireless communication, such
            as NFC. It can be disconnected.
          </dd>
        </dl>
      </section><!-- Enum ConnectivityType -->
    </section><!-- Interface Reader -->
    <!-- - - - - - - - - - - - Interface Session - - - - - - - - - -->
    <section>
      <h2>
        <a>Session</a> Interface
      </h2>
      <p>
        The <a>Session</a> interface provides ...
      </p>
      <dl title="interface Session" class="idl">
        <dt>
          readonly attribute octet[] atr
        </dt>
        <dd>
          This attribute MUST return the <a>Answer to Reset</a> provided by the
          secure element, or <code>null</code> if the secure element does not
          provide one.
        </dd>
        <dt>
          Promise&amp;lt;Channel> openBasicChannel()
        </dt>
        <dd>
          This methods opens a <a>basic channel</a> to communicate with a
          secure element application. Once this channel has been opened by an
          application, it is considered to be "locked" to other applications:
          any other call to this method will fail until this <a>basic
          channel</a> is closed. Some secure elements might always deny opening
          a basic channel.
          <dl class='parameters'>
            <dt>
              octet[] aid
            </dt>
            <dd>
              This parameter value MUST either be:
              <ul>
                <li>The complete <a>Application Identifier</a> of the targeted
                application on the secure element;
                </li>
                <li>A partial <a>Application Identifier</a> matching a set of
                targeted applications on the secure element, in which case the
                channel will be opened on the first matching application;
                </li>
                <li>
                  <code>null</code> if the channel should be opened on the
                  default application.
                </li>
              </ul>
            </dd>
          </dl>
          <div class="note">
            See <a href="#note-promise">note on <code>Promise</code></a>
          </div>
        </dd>
        <dt>
          Promise&amp;lt;Channel> openLogicalChannel()
        </dt>
        <dd>
          This methods opens a <a>logical channel</a> to communicate with a
          secure element application. It is up to the secure element to choose
          which logical channel will be used.
          <dl class='parameters'>
            <dt>
              octet[] aid
            </dt>
            <dd>
              This parameter value MUST either be:
              <ul>
                <li>The complete <a>Application Identifier</a> of the targeted
                application on the secure element;
                </li>
                <li>A partial <a>Application Identifier</a> matching a set of
                targeted applications on the secure element, in which case the
                channel will be opened on the first matching application;
                </li>
                <li>
                  <code>null</code> if the channel should be opened on the
                  default application.
                </li>
              </ul>
            </dd>
          </dl>
          <div class="note">
            See <a href="#note-promise">note on <code>Promise</code></a>
          </div>
        </dd>
        <dt>
          Promise&amp;lt;Session> close()
        </dt>
        <dd>
          Closes the connection with the Secure Element. This will close any
          channels opened by this application with this Secure Element.
          Invoking <code>close()</code> method on an already closed session is
          an idempotent operation.
          <div class="note">
            See <a href="#note-promise">note on <code>Promise</code></a>
          </div>
        </dd>
      </dl>
    </section><!-- Interface Session -->
    <!-- - - - - - - - - - - - Interface Channel - - - - - - - - - -->
    <section>
      <h2>
        <a>Channel</a> Interface
      </h2>
      <p>
        The <a>Channel</a> interface provides ...
      </p>
      <dl title="interface Channel" class="idl">
        <dt>
          readonly attribute boolean isBasicChannel
        </dt>
        <dd>
          This attribute must return TRUE if this channel is a <a>basic
          channel</a>, it MUST return FALSE otherwise.
        </dd>
        <dt>
          readonly attribute ArrayBufferView openResponse
        </dt>
        <dd>
          This attribute MUST return the secure element's response to the
          channel opening operation. It MUST be <code>null</code> if the
          channel was opened on the default secure element application (no
          <a>AID</a> was provided in the open channel operation).
        </dd>
        <dt>
          Promise&amp;lt;ArrayBufferView> selectNext()
        </dt>
        <dd>
          Updates the targeted application of this channel to be the next one
          matching the partial <a>Application Identifier</a> passed when this
          channel was open. Invoking this method MUST fail with
          <code>invalid_state</code> error if this channel was not open with a
          partial AID, or with the <code>no_application</code> error if there
          is no next application matching that partial AID. In that case the
          application associated to this channel is unchanged. If a next
          application has been found and associated to this channel, this
          operation succeeds and returns the secure element's response. This
          response value MUST be assigned to the <code>openResponse</code>
          attribute.
          <div class="note">
            See <a href="#note-promise">note on <code>Promise</code></a>
          </div>
        </dd>
        <dt>
          Promise&amp;lt;SEResponse> transmit()
        </dt>
        <dd>
          <p>
            This method transmits a command to the secure element. The user
            agent MUST ensure the synchronisation between all the concurrent
            calls to this method: a command must not be sent to a secure
            element while a response is still pending on any channel from this
            same secure element.
          </p>
          <p>
            The channel information in the <a>class byte</a> in the <a>APDU
            command</a> will be ignored. The system MAY modify the <a>class
            byte</a> of the command to ensure the APDU is transported on this
            channel. To ensure the invoking web application does not exit from
            the scope of this channel, the user agent MUST reject the following
            commands:
          </p>
          <ul>
            <li>MANAGE_CHANNEL (INS=0x70)
            </li>
            <li>SELECT by DF Name (INS=0xA4 and P1=04)
            </li>
          </ul>
          <dl class='parameters'>
            <dt>
              SECommand cmd
            </dt>
            <dd>
              The command to send to the secure element application.
            </dd>
          </dl>
          <div class="note">
            See <a href="#note-promise">note on <code>Promise</code></a>
          </div>
        </dd>
        <dt>
          Promise&amp;lt;ArrayBufferView> transmit()
        </dt>
        <dd>
          <p>
            This method behaves exactly as the transmit method above, excepts
            that both its parameter and the response are passed as a raw binary
            data. Before transmitting the command to the secure element, the
            implementation of this method MUST set the logical channel in the
            <a>class byte</a> of the command so that it fits the channel
            allocated to this <a>Channel</a> object.
          </p>
          <dl class='parameters'>
            <dt>
              ArrayBufferView cmd
            </dt>
            <dd>
              The raw command to send to the secure element application. The
              channel information in the <a>class byte</a> of the command
              (first octet of the cmd data) will be ignored.
            </dd>
          </dl>
        </dd>
        <dt>
          Promise&amp;lt;Channel> close()
        </dt>
        <dd>
          This method closes this session object. If a transmit operation is
          still waiting for the secure element response, the user agent must
          terminate that asynchronous operation with a <code>closed</code>
          error status. Invoking <code>close()</code> method on an already
          closed channel is an idempotent operation.
          <div class="note">
            See <a href="#note-promise">note on <code>Promise</code></a>
          </div>
        </dd>
      </dl>
    </section><!-- Interface Channel -->
    <!-- - - - - - - - - - - - Interface SECommand - - - - - - - - - -->
    <section>
      <h2>
        <a>SECommand</a> Interface
      </h2>
      <p>
        The <a>SECommand</a> interface represents an <a>APDU command</a> that
        can be sent to a secure element.
      </p>
      <dl title=
      "[Constructor(octet data, octet ins, octet p1, octet p2, optional ArrayBufferView data, optional octet le)] interface SECommand"
      class="idl">
        <dt>
          attribute octet cla
        </dt>
        <dd>
          <a>Class byte</a>
        </dd>
        <dt>
          attribute octet ins
        </dt>
        <dd>
          <a>Instruction byte</a>
        </dd>
        <dt>
          attribute octet p1
        </dt>
        <dd>
          First octet of the <a>parameter bytes</a>
        </dd>
        <dt>
          attribute octet p2
        </dt>
        <dd>
          Second octet of the <a>parameter bytes</a>
        </dd>
        <dt>
          attribute ArrayBufferView data
        </dt>
        <dd>
          <a>Data field bytes</a>, or <code>null</code> if command has no data
        </dd>
        <dt>
          attribute unsigned short le
        </dt>
        <dd>
          The length of the expected response data, or <code>-1</code> if
          application does not require a specific length
        </dd>
      </dl>
    </section><!-- Interface SECommand -->
    <!-- - - - - - - - - - - - Interface SEResponse - - - - - - - - - -->
    <section>
      <h2>
        <a>SEResponse</a> Interface
      </h2>
      <p>
        The <a>SEResponse</a> interface represents an <a>APDU response</a>
        received from a secure element.
      </p>
      <dl title="[Constructor(ArrayBufferView raw)] interface SEResponse"
      class="idl">
        <dt>
          readonly attribute octet sw1
        </dt>
        <dd>
          First octet of response's <a>status word</a>
        </dd>
        <dt>
          readonly attribute octet sw2
        </dt>
        <dd>
          Second octet of response's <a>status word</a>
        </dd>
        <dt>
          readonly attribute ArrayBufferView data
        </dt>
        <dd>
          The response's <a>data field bytes</a>
        </dd>
        <dt>
          boolean isStatus()
        </dt>
        <dd>
          Utility method to test the <a>status word</a> of an <a>APDU
          response</a>. This method MUST return <code>true</code> if the
          parameters match the value of the response.
          <dl class='parameters'>
            <dt>
              octet sw1
            </dt>
            <dd>
              Value to compare to the first octet of response's <a>status
              word</a>, or <code>null</code> if this first octet may have any
              value.
            </dd>
            <dt>
              octet sw2
            </dt>
            <dd>
              Value to compare to the second octet of response's <a>status
              word</a>, or <code>null</code> if this second octet may have any
              value.
            </dd>
          </dl>
        </dd>
      </dl>
    </section><!-- Interface SEResponse -->
    <!-- - - - - - - - - - - - - -  SEError - - - - - - - - - - - - - - - - -->
    <section>
      <h2>
        The <code>SEError</code> enum
      </h2>
      <div class="note">
        From latest <a>Promise</a> specification, it seems this error type
        should extend ECMAScript Error type
      </div>
      <p>
        In the interfaces defined above, some method return a <a>Promise</a>
        object. If an error occurs during the execution of any of these
        methods, the <code>reject()</code> method of promise's resolver will be
        invoked with an error value of the type <a>SEError</a>:
      </p>
      <dl title="enum SEError" class="idl">
        <dt>
          unknown
        </dt>
        <dd>
          Internal error, no further details available
        </dd>
        <dt>
          io
        </dt>
        <dd>
          Communication error
        </dd>
        <dt>
          security
        </dt>
        <dd>
          A security condition was not fulfilled
        </dd>
        <dt>
          invalid_state
        </dt>
        <dd>
          The target object was not in the proper state to execute the
          operation
        </dd>
        <dt>
          invalid_value
        </dt>
        <dd>
          The method was invoked with an incorrect parameter value
        </dd>
        <dt>
          no_channel
        </dt>
        <dd>
          Tentative to open a channel failed because no channel is available
        </dd>
        <dt>
          no_application
        </dt>
        <dd>
          The requested application was not found on the secure element
        </dd>
        <dt>
          closed
        </dt>
        <dd>
          The operation could not be fulfilled because the target object is
          closed
        </dd>
      </dl>
    </section><!-- SEError -->
    <!-- - - - - - - - - - - - - -  Examples  - - - - - - - - - - - - - - - - -->
    <section>
      <h2>
        Code example
      </h2>
      <p>
        The javascript code excerpt below shows how a web application can wait
        for a card to be present, and send it an APDU command:
      </p>
      <div class="note">
        See <a href="#note-promise">note on <code>Promise</code></a>
      </div>
      <pre class="example highlight">

            // my application identifier
            var myAppId = ...;
            // my application command
            var myAppCmd = new SECommand(...);
            
            // get secure element manager
            var seMgr = navigator.secureElementManager;
            
            // register sepresent event handler
            seMgr.onsepresent = function(reader) {
            
              // open session
              reader.openSession()
              .then(

                function (session) {
                  // open a basic channel to my application
                  return session.openBasicChannel(myAppID);
                }

              ).then(

                function (channel) {
                  // open a basic channel to my application
                  return channel.transmit(myAppCmd);
                }

              ).then(

                function (response) {
                  if (!response.isStatus(0x90, 0x00) {
                    // this might be an error
                    // ...
                  }
                }

              );
            };

</pre>
      <p>
        For simplicity and readability reasons, the code above omits the error
        handling and closing operations that would have to be done in a real
        web application.
      </p>
    </section><!-- Examples -->
    <!-- - - - - - - - - - - - - -  Changes - - - - - - - - - - - - - - - - -->
    <section class="appendix" id="Changes">
      <h2>
        Changes
      </h2>
      <p>
        The complete list of changes can be viewed on <a href=
        "https://github.com/opoto/secure-element/commits/gh-pages">Github</a>.
        You can also check the <a href=
        "https://github.com/opoto/secure-element/issues">issues</a>.
      </p>
    </section>
    <!-- - - - - - - - - - - - - - Acknowledgements - - - - - - - - - - - - - - -->
    <section>
      <h2>
        Acknowledgements
      </h2>
      <p>
        Thanks...
      </p>
    </section>
  </body>
</html>
